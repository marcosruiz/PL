/* Generated By:JavaCC: Do not edit this line. minilengcompiler.java */
package minilengcompiler;
import java.io.*;
import java.util.*;

public class minilengcompiler implements minilengcompilerConstants {
  static Token tk;
  static TablaHash thLex = new TablaHash();
  static TablaHash thSin = new TablaHash();
  /*
   * El nombre del fichero debe ir como ultimo parametro
   */
  public static void main(String args []) throws ParseException{
    try
    {

            int longitud = args.length;
            if(longitud == 0 || args[args.length-1].charAt(0) == '-')
            {
                //Entrada estandar                minilengcompiler parser = new minilengcompiler(System.in);
                System.out.println("Reading from standard input ...");
            }
            else
            {
                FileInputStream fis = new FileInputStream(args[longitud-1]);
                        minilengcompiler parser = new minilengcompiler(fis);
                        System.out.println("Reading from " + args[longitud-1] + " ...");
            }

              try
              {
                minilengcompiler.Programa();
                /*
	      	 * Gestion -lex_stats y -syntax-stats
	      	 */

                boolean lex_stats = false;
                boolean syntax_stats = false;
                if(longitud!=0)
                {
                                for(int i=0; i<longitud;i++)
                                {
                                        if(args[i].equals("-lex_stats"))
                                        {
                                                lex_stats = true;
                                        }
                                        if(args[i].equals("-syntax-stats"))
                                        {
                                                syntax_stats = true;
                                        }
                                }
                }
                        String clave, repeticiones;
                if(lex_stats)
                {
                                System.out.println("Analisis lexico finalizado sin errores");
                                Enumeration <String> lista = thLex.dameClaves();
                                while(lista.hasMoreElements())
                                {
                                        clave = lista.nextElement();
                                        repeticiones = thLex.leer(clave);
                                        System.out.println("Token " + clave + ": reconocido " + repeticiones + " veces");
                                }
                                System.out.println();
                }
                if(syntax_stats)
                {
                        Enumeration <String> listaSin = thSin.dameClaves();
                                System.out.println("Analisis sintactico finalizado sin errores");
                                while(listaSin.hasMoreElements())
                                {
                                        clave = listaSin.nextElement();
                                        repeticiones = thSin.leer(clave);
                                        System.out.println("Se han reconocido " + repeticiones + " " + clave);
                                }
                                System.out.println();
                }
              }
              catch (TokenMgrError e)
              {
                /*System.out.println("Oops.");	        System.out.println(e.getMessage());*/
                if(tk != null)
                {
                        System.out.println("ERROR LEXICO (" + tk.beginLine + ", " + tk.beginColumn + "): simobolo no reconocido:  " + tk.image +" ");

                }
                else
                {
                                System.out.println("ERROR LEXICO AL COMIENZO DEL PROGRAMA");
                }
              }
              catch(ParseException e)
              {
                System.out.println("ERROR SINTACTICO (" + tk.beginLine + ", " + tk.beginColumn + ")");
              }
            }catch(FileNotFoundException e){
                e.printStackTrace();
                }
  }

/*void comienzo() :{}{  (token())+< EOF >}
void token() :
{}{
  tk = <tPLUS> {thLex.insertar("plus");}
| tk = < tMINUS> {thLex.insertar("minus");}
| tk = < tMULTIPLY> {thLex.insertar("multiply");}
| tk = < tDIVIDE> {thLex.insertar("divide");}| tk = < tPROGRAMA > {thLex.insertar("programa");}
| tk = < tAND > {thLex.insertar("and");}
| tk = < tOR > {thLex.insertar("or");}
| tk = < tNOT >  {thLex.insertar("not");}
| tk = < tPRINCIPIO > {thLex.insertar("principio");}
| tk = < tFIN > {thLex.insertar("fin");}
| tk = < tSI > {thLex.insertar("si");}
| tk = < tENT > {thLex.insertar("ent");}
| tk = < tSI_NO > {thLex.insertar("sino");}
| tk = < tFSI > {thLex.insertar("fsi");}
| tk = < tMQ > {thLex.insertar("mq");}
| tk = < tFMQ > {thLex.insertar("fmq");}
| tk = < tESCRIBIR > {thLex.insertar("escribir");}
| tk = < tLEER > {thLex.insertar("leer");}
| tk = < tMOD > {thLex.insertar("mod");}
| tk = < tDIV > {thLex.insertar("div");}
| tk = < tENTERO > {thLex.insertar("entero");}
| tk = < tBOOLEANO > {thLex.insertar("booleano");}
| tk = < tCARACTER > {thLex.insertar("caracter");}
| tk = < tTRUE > {thLex.insertar("true");}
| tk = < tFALSE > {thLex.insertar("flase");}
| tk = < tENTACAR > {thLex.insertar("entacar");}
| tk = < tCARAENT > {thLex.insertar("caraent");}
| tk = < tACCION > {thLex.insertar("accion");}
| tk = < tVAL > {thLex.insertar("val");}
| tk = < tREF > {thLex.insertar("ref");}
| tk = < tMAYOR > {thLex.insertar("mayor");}
| tk = < tMENOR > {thLex.insertar("menor");}
| tk = < tIGUAL > {thLex.insertar("igual");}
| tk = < tMAI > {thLex.insertar("mai");}
| tk = < tMEI > {thLex.insertar("mei");}
| tk = < tNI > {thLex.insertar("ni");}
| tk = < tOPAS > {thLex.insertar("opas");}
| tk = < tIDENTIFICADOR > {thLex.insertar("identificador");}
| tk = < tCONST > {thLex.insertar("const");}
| tk = < tCAROCAD > {if(tk.image.length() == 3){
  thLex.insertar("letra");}else{
  thLex.insertar("cadena");}
}
| tk = < tCOMA > {thLex.insertar("coma");}
| tk = < tPUNTOYCOMA > {thLex.insertar("puntoycoma");}
| tk = < tAPAR > {thLex.insertar("apar");}
| tk = < tCPAR > {thLex.insertar("cpar");}
| tk = < tACOR > {thLex.insertar("acor");}
| tk = < tCCOR > {thLex.insertar("ccor");}}*/
  static final public void Programa() throws ParseException {
    tk = jj_consume_token(tPROGRAMA);
                    thLex.insertar("programa");
    tk = jj_consume_token(tIDENTIFICADOR);
                         thLex.insertar("identificador");
    tk = jj_consume_token(tPUNTOYCOMA);
    declaracion_variables();
    declaracion_acciones();
    bloque_sentencias();
  }

  static final public void declaracion_variables() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tENTERO:
      case tBOOLEANO:
      case tCARACTER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      declaracion();
      tk = jj_consume_token(tPUNTOYCOMA);
    }
  }

  static final public void declaracion() throws ParseException {
    tipo_variables();
    identificadores();
  }

  static final public void tipo_variables() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tENTERO:
      tk = jj_consume_token(tENTERO);
                    thLex.insertar("entero");
      break;
    case tCARACTER:
      tk = jj_consume_token(tCARACTER);
                       thLex.insertar("caracter");
      break;
    case tBOOLEANO:
      tk = jj_consume_token(tBOOLEANO);
                       thLex.insertar("booleano");
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void identificadores() throws ParseException {
    tk = jj_consume_token(tIDENTIFICADOR);
                          thLex.insertar("identificador");
                                                              thSin.insertar("variables");
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMA:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      tk = jj_consume_token(tCOMA);
      tk = jj_consume_token(tIDENTIFICADOR);
                                          thLex.insertar("identificador");
                                                                              thSin.insertar("variables");
    }
  }

  static final public void declaracion_acciones() throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tACCION:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
      declaracion_accion();
    }
  }

  static final public void declaracion_accion() throws ParseException {
 thSin.insertar("funciones");
    cabecera_accion();
    tk = jj_consume_token(tPUNTOYCOMA);
    declaracion_variables();
    declaracion_acciones();
    bloque_sentencias();
  }

  static final public void cabecera_accion() throws ParseException {
    tk = jj_consume_token(tACCION);
                    thLex.insertar("accion");
    tk = jj_consume_token(tIDENTIFICADOR);
                          thLex.insertar("identificador");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAPAR:
      parametros_formales();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
  }

  static final public void parametros_formales() throws ParseException {
    tk = jj_consume_token(tAPAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVAL:
    case tREF:
      parametros();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tPUNTOYCOMA:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_4;
        }
        tk = jj_consume_token(tPUNTOYCOMA);
        parametros();
      }
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    tk = jj_consume_token(tCPAR);
  }

  static final public void lista_parametros() throws ParseException {
    tk = jj_consume_token(tIDENTIFICADOR);
                           thLex.insertar("identificador");
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      tk = jj_consume_token(tCOMA);
      tk = jj_consume_token(tIDENTIFICADOR);
                                          thLex.insertar("identificador");
    }
  }

  static final public void parametros() throws ParseException {
    clase_parametros();
    tipo_variables();
    lista_parametros();
  }

  static final public void clase_parametros() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tVAL:
      tk = jj_consume_token(tVAL);
                 thLex.insertar("val");
      break;
    case tREF:
      tk = jj_consume_token(tREF);
                                                        thLex.insertar("ref");
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void bloque_sentencias() throws ParseException {
    tk = jj_consume_token(tPRINCIPIO);
                       thLex.insertar("principio");
    lista_sentencias();
    tk = jj_consume_token(tFIN);
                                                                                      thLex.insertar("fin");
  }

  static final public void lista_sentencias() throws ParseException {
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSI:
      case tMQ:
      case tESCRIBIR:
      case tLEER:
      case tIDENTIFICADOR:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_6;
      }
      sentencia();
    }
  }

  static final public void sentencia() throws ParseException {
 thSin.insertar("sentencias");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tLEER:
      leer();
      tk = jj_consume_token(tPUNTOYCOMA);
      break;
    case tESCRIBIR:
      escribir();
      tk = jj_consume_token(tPUNTOYCOMA);
      break;
    case tIDENTIFICADOR:
      asignacion_o_invocacion();
      break;
    case tSI:
      seleccion();
      break;
    case tMQ:
      mientras_que();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void leer() throws ParseException {
    tk = jj_consume_token(tLEER);
                thLex.insertar("leer");
    tk = jj_consume_token(tAPAR);
    lista_asignables();
    tk = jj_consume_token(tCPAR);
  }

  static final public void lista_asignables() throws ParseException {
    tk = jj_consume_token(tIDENTIFICADOR);
                           thLex.insertar("identificador");
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_7;
      }
      tk = jj_consume_token(tCOMA);
      tk = jj_consume_token(tIDENTIFICADOR);
                                                                                                     thLex.insertar("identificador");
    }
  }

  static final public void escribir() throws ParseException {
    tk = jj_consume_token(tESCRIBIR);
                    thLex.insertar("escribir");
    tk = jj_consume_token(tAPAR);
    lista_escribibles();
    tk = jj_consume_token(tCPAR);
  }

  static final public void lista_escribibles() throws ParseException {
    factor();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_8;
      }
      tk = jj_consume_token(tCOMA);
      factor();
    }
  }

  static final public void asignacion_o_invocacion() throws ParseException {
    tk = jj_consume_token(tIDENTIFICADOR);
                           thLex.insertar("identificador");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tOPAS:
      asignacion();
      break;
    case tPUNTOYCOMA:
    case tAPAR:
      invocacion_accion();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void asignacion() throws ParseException {
 thSin.insertar("asignaciones");
    tk = jj_consume_token(tOPAS);
    expresion();
    tk = jj_consume_token(tPUNTOYCOMA);
  }

  static final public void invocacion_accion() throws ParseException {
 {thSin.insertar("invocaciones");}
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAPAR:
      argumentos();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    tk = jj_consume_token(tPUNTOYCOMA);
  }

  static final public void mientras_que() throws ParseException {
  thSin.insertar("bucles");
    tk = jj_consume_token(tMQ);
              thLex.insertar("mq");
    expresion();
    lista_sentencias();
    tk = jj_consume_token(tFMQ);
                                                                                 thLex.insertar("fmq");
  }

  static final public void seleccion() throws ParseException {
 thSin.insertar("selecciones");
    tk = jj_consume_token(tSI);
                thLex.insertar("si");
    expresion();
    tk = jj_consume_token(tENT);
                                                                  thLex.insertar("ent");
    lista_sentencias();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tSI_NO:
      tk = jj_consume_token(tSI_NO);
                    thLex.insertar("sino");
      lista_sentencias();
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    tk = jj_consume_token(tFSI);
  }

  static final public void argumentos() throws ParseException {
    tk = jj_consume_token(tAPAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMINUS:
    case tNOT:
    case tTRUE:
    case tFALSE:
    case tENTACAR:
    case tCARAENT:
    case tIDENTIFICADOR:
    case tCONST:
    case tCAROCAD:
    case tAPAR:
      lista_expresiones();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    tk = jj_consume_token(tCPAR);
  }

  static final public void lista_expresiones() throws ParseException {
    expresion();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_9;
      }
      tk = jj_consume_token(tCOMA);
      expresion();
    }
  }

  static final public void expresion() throws ParseException {
 thSin.insertar("expresiones");
    expresion_simple();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMAYOR:
    case tMENOR:
    case tIGUAL:
    case tMAI:
    case tMEI:
    case tNI:
      operador_relacional();
      expresion_simple();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
  }

  static final public void operador_relacional() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMAYOR:
      tk = jj_consume_token(tMAYOR);
                  thLex.insertar("mayor");
      break;
    case tMENOR:
      tk = jj_consume_token(tMENOR);
                   thLex.insertar("menor");
      break;
    case tIGUAL:
      tk = jj_consume_token(tIGUAL);
                   thLex.insertar("igual");
      break;
    case tMAI:
      tk = jj_consume_token(tMAI);
                 thLex.insertar("mai");
      break;
    case tMEI:
      tk = jj_consume_token(tMEI);
                 thLex.insertar("mei");
      break;
    case tNI:
      tk = jj_consume_token(tNI);
                thLex.insertar("ni");
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void expresion_simple() throws ParseException {
    termino();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPLUS:
      case tMINUS:
      case tOR:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
      operador_aditivo();
      termino();
    }
  }

  static final public void operador_aditivo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tPLUS:
      tk = jj_consume_token(tPLUS);
                  thLex.insertar("plus");
      break;
    case tMINUS:
      tk = jj_consume_token(tMINUS);
                   thLex.insertar("minus");
      break;
    case tOR:
      tk = jj_consume_token(tOR);
                thLex.insertar("or");
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void termino() throws ParseException {
    factor();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMULTIPLY:
      case tDIVIDE:
      case tAND:
      case tMOD:
      case tDIV:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_11;
      }
      operador_multiplicativo();
      factor();
    }
  }

  static final public void operador_multiplicativo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMULTIPLY:
      tk = jj_consume_token(tMULTIPLY);
                      thLex.insertar("multiply");
      break;
    case tDIVIDE:
      tk = jj_consume_token(tDIVIDE);
                    thLex.insertar("divide");
      break;
    case tDIV:
      tk = jj_consume_token(tDIV);
                 thLex.insertar("div");
      break;
    case tMOD:
      tk = jj_consume_token(tMOD);
                 thLex.insertar("mod");
      break;
    case tAND:
      tk = jj_consume_token(tAND);
                  thLex.insertar("and");
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void factor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMINUS:
      tk = jj_consume_token(tMINUS);
                   thLex.insertar("minus");
      factor();
      break;
    case tNOT:
      tk = jj_consume_token(tNOT);
               thLex.insertar("not");
      factor();
      break;
    case tAPAR:
      tk = jj_consume_token(tAPAR);
      expresion();
      tk = jj_consume_token(tCPAR);
      break;
    case tENTACAR:
      tk = jj_consume_token(tENTACAR);
                   thLex.insertar("entacar");
      tk = jj_consume_token(tAPAR);
      expresion();
      tk = jj_consume_token(tCPAR);
      break;
    case tCARAENT:
      tk = jj_consume_token(tCARAENT);
                   thLex.insertar("caraent");
      tk = jj_consume_token(tAPAR);
      expresion();
      tk = jj_consume_token(tCPAR);
      break;
    case tIDENTIFICADOR:
      tk = jj_consume_token(tIDENTIFICADOR);
                         thLex.insertar("identificador");
      break;
    case tCONST:
      tk = jj_consume_token(tCONST);
                 thLex.insertar("const");
      break;
    case tCAROCAD:
      tk = jj_consume_token(tCAROCAD);
                   if(tk.image.length() == 3){thLex.insertar("letra");}else{thLex.insertar("cadena");}
      break;
    case tTRUE:
      tk = jj_consume_token(tTRUE);
                thLex.insertar("true");
      break;
    case tFALSE:
      tk = jj_consume_token(tFALSE);
                 thLex.insertar("false");
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public minilengcompilerTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[25];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1c000000,0x1c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd10000,0xd10000,0x0,0x0,0x0,0x0,0x40000,0xe0002080,0x0,0x0,0x0,0x10c0,0x10c0,0x3000b00,0x3000b00,0xe0002080,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x10000,0x2,0x40000,0x20000,0xc,0x10000,0xc,0x800,0x800,0x10000,0x10000,0x60400,0x40000,0x0,0x4c801,0x10000,0x3f0,0x3f0,0x0,0x0,0x0,0x0,0x4c801,};
   }

  /** Constructor with InputStream. */
  public minilengcompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public minilengcompiler(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new minilengcompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public minilengcompiler(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new minilengcompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public minilengcompiler(minilengcompilerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(minilengcompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[54];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 25; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 54; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
